#
# data/CsvInterpretor.java
#
CsvBitNotSpecified = La ligne %d du fichier csv '%s' ne contient pas le bit %d de la variable '%s', abandon.
CsvDuplicatedBit = La ligne %d du fichier csv '%s' contient le double du bit %d de la variable '%s', abandon.
CsvDuplicatedVar = La ligne %d du fichier csv '%s' contient plusieurs fois la variable '%s', abandon.
CsvIncorrectBitOrder = La ligne %d du fichier csv '%s' contient une séquence binaire mal ordonnée pour la variable '%s', abandon.
CsvIncorrectEmpty = La ligne %d du fichier csv '%s' contient un champ vide incorrect à la position %d, abandon.
CsvIncorrectLine = La ligne %d du fichier csv '%s' comporte %d entrées au lieu des %d obligatoires, abandon.
CsvIncorrectVarName = La ligne %d du fichier csv '%s' contient l'étiquette malformattée '%s', abandon
CsvInvalidEntry = La ligne %d du fichier csv '%s' contient une entrée non valide '%s' dans le champ %d, abandon.
CsvNoInputsFound = La ligne %d du fichier csv '%s' ne contient aucune entrée, abandon.
CsvNoSepFound = La ligne %d du fichier csv '%s' ne contient aucun champ séparateur, abandon.
CsvNotEnoughEmpty = La ligne %d du fichier csv '%s' ne contient pas assez de champs vides après la variable '%s', abandon.
#
# data/ExpressionRenderData.java
#
expressionEmpty = (vide)
#
# file/AnalyzerTexWriter.java
#
latexBabelLanguage = french
latexEmpty = Analyseur vide
latexEmptyText = Comme l'analyseur n'avait pas de variables d'entrée et/ou de sortie au moment où ce document a été généré, rien ne s'affiche.
latexHeader = Document généré par Logisim-evolution sur %s
latexIntroduction = introduction
latexIntroductionText = Ce document a été généré par logisim-evolution. Toute partie des sources TeX peut être utilisée dans vos propres documents sans aucun problème. Si vous souhaitez utiliser tout/partie des sources TeX générées, veuillez (1) ne pas oublier d’inclure les packages requis et (2) inclure une remarque indiquant que cette source a été générée par logisim-evolution.
latexKarnaugh = Diagrammes de Karnaugh
latexKarnaughEmpty = Diagrammes de Karnaugh vides
latexKarnaughFilledIn = Rempli dans les diagrammes de Karnaugh
latexKarnaughFilledInGroups = Rempli dans les diagrammes de Karnaugh avec des couvertures
latexKarnaughText = Cette section présente différentes versions des diagrammes de Karnaugh des fonctions données.
latexKarnaughToBig = Impossible d'afficher les diagrammes kranaugh avec plus de %d entrées.
latexMinimal = Expressions minimales
latexTruthTable = Table de vérité
latexTruthTableComlete = Table de vérité complète
latexTruthTableCompact = Table de vérité compactée
latexTruthTableText = Le tableau peut être trop gros pour être affiché sur la page. Au moment de la génération, aucun calcul n'a été effectué sur la taille du tableau par rapport à la largeur/hauteur de la page.
latexTruthTableToBig = \\\\~\\\\ La table de vérité a plus de %d entrées, cela n'a aucun sens de le montrer ici.
tableLatexFilter = Document TeX Logisim-evolution (*.tex)
#
# file/TruthtableCsvFile.java
#
tableCsvFileFilter = Table de vérité Logisim-evolution (* .csv)
#
# file/TruthtableTextFile.java
#
tableParseErrorMessage = Ignorer les erreurs et réessayer?
tableParseErrorTitle = Erreur d'analyse de la table de vérité
tableRemark1 = # Table de vérité
tableRemark2 = # Généré à partir du circuit %s
tableRemark3 = # Exporté dans %s
tableRemark4 = # Conseils et remarques sur la mise en forme: \n# * Vous pouvez modifier ce fichier, puis le réimporter dans Logisim! \n# * Tout ce qui suit un '#' correspond à un commentaire et sera ignoré. \n# * Lignes vides et lignes de séparation (par exemple, ~~~~~~) sont ignorés. \n# * Conservez les noms de colonne simples (sans espace, ni ponctuation, etc.) \n# * 'Nom [N..0]' indique une variable de N + 1 bits , alors que \n# 'Nom' à lui seul indique une variable de 1 bit. \n# * Vous pouvez utiliser 'x' ou '-' pour indiquer \ "ne vous souciez pas \" pour des \n# bits d'entrée et de sortie . \n# * Vous pouvez utiliser la notation binaire (par exemple, '10100011xxxx') ou \n# ou hex (par exemple, 'C3x'). Logisim déterminera qui est lequel.
tableTxtFileFilter = Table de vérité Logisim-evolution (* .txt)
#
# gui/Analyzer.java
#
analyzePleaseWait = SVP. attendez...
analyzerWindowTitle = Analyse Combinatoire
buildCircuitButton = Construire le circuit
exportLatexButton = Exporter TeX
exportTableButton = Exporter table
expressionTab = Expression
expressionTabTip = Visualiser et manipuler les expressions de sortie.
importTableButton = Importer table
inputsOutputsTab = Entrées & Sorties
inputsOutputsTabTip = Affichez et modifiez l'ensemble des variables d'entrée et de sortie.
minimizedTab = Karnaugh
minimizedTabTip = Visualiser les tables de Karnaugh pour chaque entrée.
tableTab = Table
tableTabTip = Visualiser et manipuler la table de vérité.
#
# gui/BuildCircuitButton.java
#
buildConfirmReplaceMessage = Etes-vous sûr de vouloir remplacer le circuit %s?
buildConfirmReplaceTitle = Confirmer le remplacement
buildDialogErrorTitle = Réalisation du circuit impossible
buildDialogTitle = Réaliser le circuit
buildDuplicatedNameError = Le nom du circuit ne peut pas être égal au nom d'une entrée ou d'une sortie. Veuillez spécifier un autre nom.
buildNameLabel = Nom du circuit:
buildNandsLabel = Utiliser des ports NAND uniquement
buildNeedCircuitError = Vous devez définir un nom de circuit.
buildNeedProjectError = Vous devez sélectionner un projet destination.
buildProjectLabel = Projet de destination:
buildTwoInputsLabel = Utiliser des portes à deux entrées uniquement
replaceCircuitAction = Remplacement du circuit
#
# gui/CsvReadParameterDialog.java
#
ConfirmCsvParameters = Continuer
cvsFilePreview = Aperçu des quatre premières lignes du fichier lu:
seperatorSpace = {espace}
SeperatorTab = {tab}
UsedQuotesInFile = Sélectionnez le caractère "quote" utilisé dans le fichier cvs:
UsedSeperatorInFile = Sélectionnez le caractère "séparateur" utilisé dans le fichier csv:
#
# gui/ExportLatexButton.java
#
cantWriteMessage = Impossible d'écrire le fichier:% s
confirmOverwriteMessage = Êtes-vous sûr de vouloir écraser le fichier %s?
confirmOverwriteTitle = Confirmer l'écrasement
notFileMessage = Pas un fichier:% s
saveButton = Exporter la  table
saveErrorTitle = Erreur d'enregistrement du fichier
#
# gui/ExpressionTab.java
#
cantImportFormatError = Impossible d'importer ce type de données
outputExpressionEdit = Expressions de sortie (double-cliquez pour éditer):
#
# gui/ImportTableButton.java
#
cantReadMessage = Impossible de lire le fichier:% s
DoNotKnowHowto = impossible de lire ou écrire des fichiers '%s' (l'extension doit être .txt ou .csv).
openButton = Exporter la  table de vérité
openErrorTitle = Erreur de lecture du fichier
#
# gui/KarnaughMapPanel.java
#
karnaughNoInputsError = Aucune entrée disponible.
karnaughNoOutputError = Aucune entrée sélectionnée.
karnaughTooManyInputsError = Trop d'entrées pour la table.
NoSelectedKmapGroup = Aucun groupe sélectionné.
SelectedKmapGroup = Groupe sélectionné:
#
# gui/MinimizedTab.java
#
expressionAltLogicrepresentation = Logique alternative
expressionCalc = Calculer une expression
expressionLogicrepresentation = Logique
expressionMathrepresentation = Mathématique
ExpressionNotation = Notation:
expressionProgbitsrepresentation = Programmation avec des bits
expressionProgboolsrepresentation = Programmation avec des booléens
KMapLinedStyle = Doublé
KmapNumberedStyle = Numéroté
KmapStyle = Style:
minimizedFormat = Format:
minimizedProductOfSums = Produit des sommes
minimizedSetButton = Définir comme expression
minimizedSumOfProducts = Somme des produits
#
# gui/OutputSelector.java
#
outputSelectLabel = Sortie:
#
# gui/TableTab.java
#
tableCompact = Réduire les lignes dupliquées
tableExpand = Afficher toutes les lignes
tableNoInputs = (pas d'entrées)
tableNoOutputs = (pas de sorties)
tableRowsShown = %d de %d lignes affichées
#
# gui/TableTabCaret.java
#
tabcaretCompactRows = Compacter les lignes
#
# gui/TableTabClip.java
#
clipPasteEndError = Le presse papier excède la fin de la table.
clipPasteErrorTitle = Erreur de collage
clipPasteSizeError = La destination doit être de la même taille que le presse papier.
clipPasteSupportedError = Le contenu du presse papier ne peut pas être collé dans l'éditeur.
#
# gui/VariableTab.java
#
inputVariables = Variables d'entrée
outputVariables = Variables de sortie
variableClickToAdd = Cliquez pour ajouter une nouvelle variable
variableDuplicateError = Le nom double une variable existante.
variableMaximumError = (Taille maximum de %s atteinte.)
variablePartError = Le nom ne peut pas contenir '%s'.
variableRangeFinalPar = Plage: manque ] directement après l'indice LSB
variableRangeInvalChar = Plage: caractères non valides après le ]
variableRangeMSBWrong = Plage: commençant par [ doit être suivi d'un nombre
variableRangeStartPar = Plage: [ manquant
variableRangeWrongLB = Plage: l'index MSB doit être plus grand / égal à l'index LSB
variableRangeWrongSep = Plage: l'index MSB et l'index LSB doivent être séparés par ..
variableStartError = Le nom doit commencer par une lettre.
#
# model/Entry.java
#
busError = Conflit entre les valeurs de sortie du circuit.
oscillateError = Le circuit oscille.
#
# model/Parser.java
#
badVariableName = %s n'est pas une variable d'entrèe.
implicitAndOperator = (AND Implicite)
invalidCharacterError = Caractéres non reconnus: %s
lparenMissingError = Il manque une parenthèse ouvrante.
missingBraceError = Aucune accolade correspondante: "%s"
missingIdentifierError = Identifiant manquant avant indice: "%s"
missingLeftOperandError = Il manque l'opérande gauche de %s.
missingRightOperandError = Il manque l'opérande droite de %s.
missingSubscriptError = Indice manquant: "%s"
rparenMissingError = Il manque une parenthèse fermante.
unexpectedApostrophe = Erreur d'apostrophe ("'")
unexpectedAssignmentError = Opérateur d'affectation inattendue: "% s"
#
# model/Var.java
#
badVariableBitFormError = Le nom de la variable doit être de la forme 'nom[i]'
badVariableColonError = Le nom de la variable doit apparaître avant ':'
badVariableIndexError = L'indice de bit variable doit être un entier
variableFormat = Les variables doivent être de la forme 'nom[N..0]'
variableTooMuchBits = Les variables ne peuvent pas avoir plus de 32 bits de large
